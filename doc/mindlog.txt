/////////////////////////////////////////////////////////////////////////////
главный объект- CGameWorld
в нём хранится 

/////////////////////////////////////////////////////////////////////////////
class _gameObject
{
	char *name;
	ObjectCreator *definition;
	_gameObject(char *name,ObjectCreator *def)
	{	
	}
};
для внешних устройств linkBoneNN (NN-номер точки привязки)- кость для привяхки устройств


способы прицеливания (графика)
1. Оружие будет представлено сабмешами (башня, пушка)
	тогда управлеине вручную (yaw, pitch), 
	оружие приконекчено отдельно к юниту (съёмное внешнее устройство)
	(пример использования- танк обыкновенный, да и вообще вся техника)
	
2. Оружие представлено одним сабмешем, есть управляемые кости (turrBone->cannBone)
	вращаем соответствующие кости (turrBone->rotateZ(horAngle) ,cannBone->rotateY(verAngle))
	(внешнее устройство, mesh+skin modifier)
	(пример использования- те же + наличие модификатора skin позволит делать 
	"органические оружия а-ля Zerg")
3. Сабмеш+анимация прицеливания
	анимация наведения по горизонтали+ анимация прицеливания по вертикали, 	
	для получения нужного положения применяем смешивание анимаций,
	horizontalTime=(angleHorizontal-minHorAngle)/(minHorAngle+maxHorAngle);
	verticalTime=(angleVertical-minVerAngle)/(minVerAngle+maxVerAngle);
	(внешнее\внутреннее устройство)
	(пример использования- пехота, всякие органические объекты)	

animation process

animations:
+stand,walk,run
+aim(horizontal,vertical)
+attack

class CWeaponGraphics
{
	void init(Entity *model);
	void setAim(float horAngle,float verAngle);
	unum {AIM_SINGLE,AIM_BONE}aimType;
};
class CWeaponAimBone:public CAimGraphics
{
	CWeaponAimBone(Entity *ent,char *horBone,char *verBone);
};

void setAimBoneHV(Entity *ent,char *horBone,chat *verBone,float horAngle,float verAngle);
void setAimBoneVH(Entity *ent,char *horBone,chat *verBone,float horAngle,float verAngle);
void setAimSimpleVH(Entity *turret,Entity *cannon,char *horBone,chat *verBone,float horAngle,float verAngle);
void setAimSimpleVH(Entity *turret,Entity *cannon,char *horBone,chat *verBone,float horAngle,float verAngle);




aim_mode:
	aimOnlySingle- returns message sucess when target aimed,aiming finishes;
	aimLock- keep target aimed

attack_mode:
	attackSingle- single shot when aimed
	attackContinious- continious attack, interrupts if target is out of aim (laser, chaingun)
	attackCrazy- continious shooting, no interrupts on aim	

enum _weaponType{
	weaponActive, //turret-like weapon,
	weaponPassive //connects to other device, manual aiming control
}weaponType;
enum _aimGraphicsType
{
	aimSimple, //we use 
	aimBones,	
	aimBlend
}aimGraphicsType;
enum _aimOrder{
	H2V, //horizontal->vertical
	V2H  //vertical->horizontal
}aimOrder;
планы:

template <class Cell>

class CLayer
{
	Cell *arData;
	int sizeX,sizeY;
	float cellWidth,cellHeight;
public:	
	CLayer(int sizex,int sizey);
	Cell *getCell(float x,float y);
	void reset();
	void init(int sizex,int sizey);
	void setCellSize(float width,flaot height);
};


Прицеливание (часть 2)

1. Определение углов на цель
2. Установка на эти углы...

Нафик!!!
у нас постоянно будут меняться углы, танк то не на месте стоит, да и не факт что
юнит с этой башней не окажется каким-нить космическим кораблём, тогда 
у нас ещё и меняется баовая система координат для этой башни.
Поэтому на первом этапе наводимся по-другому:
Каждый такт обновления:
1. Находим углы на цель, мож даже просто вектор на цель
2. Определяем, в какое направление нам нужно двигаться

Уфф, вроде пережило 2е рождение, т.е переход на новую версию огра... теперь продолжим
Давай ка сделаю я нормально прицеливание для пушки.

Не забывай заглядывать в scenerySystem::preloadModels, 
когда решишь добавлять новые модельки в игру. Без этоо они не заработают.

Давай ка я ещё раз попробую сделать наведение для 2хосевого вращательного шарнира
(т.е башенного орудия:), я понемногу буду переделывать игровые понятия к робототехнике )

В данный момент базовая кость (ось привязки) для орудий (и других устройств)
берётся как GetParentNode... пока этого достаточно, но вероятно вскоре понадобится
более гибкое решение. Как вскоре придёт, тогда и сделаю.

Во,ещё напоминание: когда мы не включаем какой-нить анимации, то у нас система
координат малясь другая. Не помню каким образом, но стоит помнить, что
здесь скорее всего грабли лежат

Пути дальнейшего развития среды:
Сейчас вычисления положения объектов 

Наведение заработало! Да ещё кажись и в общем виде задача решена, т.е
для прозвольного начального положения и ориентации башни\пушки. 
И без халявы всякой. Сам геометрический алгоритм потом в комментариях опишу.
Вообщем полон эмоций, ссу кипятком, не ошпариться бы теперь...

теперь офизичить бы движок, добавить сюда сам уровень и ИИ

добавил скрипты на tolua... точнее доступ к функциям gameWorld'a из скриптов

можно ныне создавать кучу объектов прям в скрипте...
было бы классно ещё сделать консоль, чтобы отуда работать со скриптами

Теперь нужно снова погрузиться в дебри classFactory чтобы научить 
его самостоятельно инициализировать поля

27.08.07
Вернулся домой с отпуска, поглядел состояние проека, оказалось что я затёр 
файл описания объектов да и начальный скрипт. Не понятно что с моделями.

Сейчас попробую сделать заготовку для воксельного уровня.
Это значит что нужно для начала начать интеграцию игрового 
и физического двигов.

Модели достал из предыдущей версии, скрипт переписал. Стало лучше.

Так, с заготовкой более менее прояснилось...
Для каждой ячейки карты спец меш. Вообщем то он стандартный. Надо бы сначала сделать
инициализацию ентого меша. Упрощённую версию вгонять в физикс

У каждой ячейки ссылки на ячейки- соседи. ИМХО стоит ограничиться 6ю.
28.08.07
как бы затолкать инициализацию баунда для solid'ов...


1. соединить solid с физиксом	- OK
2. завести физику.					- OK

Проблема!
При управлении на уровне скоростей сила тяжести перестаёт работать!
Т.е мы вручную устанавливаем скорость вместо той, что рассчитывается из учёта действия внешних сил
Видимо придётся применять characterController...

29.08.07
Теперь подумаем об управлении моделью робота.
Сейчас вижу 2 решения:
1) Сделать девайс, который по сути и является этой тележкой.
2) Комплексные объекты... Т.е к роботу крепим колёса-приводы, управление напрямую к колёсам...
не нравится мне это.

Главная проблема:
невозможно пока связать напрямую управление устройствами, например с мышки...

Реализовать классы:
Joint
Mover4Wheel
Bone
ParticleSystem

Возможности:
1. Нужно сделать функцию привязки одного объекта к другому.
Привязка к осям (костям)

Бессмыссленное замечание:
Понемногу вся эта хрень приобретает вид нормального двига...
Если бы был умнее, собрал бы всё это ещё год назад.

Die
Idle
Shoot
Slump
Walk

Снова вносим поправки в архитектуру. Нужно добавить возможность всей системе
работать незавичимо от DynamicsSystem & ScenerySystem

Объекты DynamicsSystem:

Body-Box
Body-Capsule
Body-Plane

Joint-Revolute
Joint-Cylindric
Joint-Prismatic
Joint-6DOF

Объекты ScenerySystem:

Node-Mesh
Node-Light
Node-Bone
Node-Camera

А заодно надо в неё вместить всю загрузку ОГРа, работу с окнами, разрешением и т.п
Объекты ControlSystem

ControlDirect-Mouse
ControlDirect-Keyboard
ControlDirect-Joystick

ControlGeneric-Unit
ControlGeneric-AI

Для этой системыы стоит определить метод lock, благодаря которому узел данной системы
будет принимать все события данного типа (например ввод-вывод с клавиатуры будет подаваться
только на объект "игрок").
Нужна поддержка карты комманд. Конечные объекты не должны работать на уровне
"нажата кнопка А". Скорее всего стоит передавать команды в виде "нажать на педаль газа" и т.п
Не забывай, что делаешь не движок, и не враппер к нему, а ООП среду для моделирования 
объектов. И среда должна работать (со стороны пользователя) только в терминах того
мира, который моделируем. Т.е мы должны передавать конечные комадны, а не начальные

Вот здесь уже становиться вопрос о назначении всей этой хреновины, что я уже год с лишним ваяю.
Поидее основное назначение- готовая объектная среда моделирования. 
Нужно срочно переделывать ClassFactory. Вероятно стоит выделить это в отдельный проект

уровень...

надо по-быстрому его сделать.
1. Что это такое: набор объектов, объединённый общими свойствами. Во, предопределённый,
и, как правило, статичный набор. Значит надо бы сделать возможность сериализации. 
Сейчас эта возможность обеспечивается скриптами. Стоит ли продвигать этот подход, или
реализовать что-нибудь более компактное и быстрое? Думаю стоит


Почти приделал новую версию classFactory, теперь нормально работает загрузка вложенных объектов,
поправил имена функций, сделал работу фабрики через интерфейс.
Теперь бы сделать поддержку наследования в фабрике. А потом снова возвращаемся в интеграцию
с Lua. После этого займусь ка я управлением.
Для этого стоит начать переделывание класса FrameListener и Application.
Слежение за кадрами надо взгрузить на спец. класс.

демка физики Feel The Force.
Идея. Реализовать идею мнипуляцией объектами на расстоянии (телекинез, гравипушка и же с ними)
Вариант реализации.
1. Что-то вроде квеста
2. Арена вроде Jedi Academy

Изменения в архитектуре:
Для класса SystemNode нужно сделать что-то типа SystemNodeListener'a, 
который будет обабатывать соответствующие события.- Пока не стоит торопиться.
Эти классы будут необходимы, но их структура будет ясна немного позднее.

Сделать сегодня экспортёр 3дмакса что-ли...

[25.01.08] Окончательно перенести инициализацию OGRE в ScenerySysem
потом можно Дмитрию отправлять.
Ок. Инициализация графики теперь полностью в ScenerySystem. Возможно позже придётся 
из него выделить класс Renderer, но надеюсь это будет нескоро.
Теперь нужно быстренько сделать класс, перехватывающий событие отрисовки кадра.
Что-то типа специализированного FrameListener'a


[19.04.08] Обнаружены проблемы с classFactory2
	Возможно требуется обследование в отдельном классе
[09.05.08] Отлаживаю ClassFactory. нужно обдумать, как перекидывать параметры объектов в систему 
	Потом отладить keyboard controller

	 
	При отсылании сообщения о закрытии сам отсылатель отключается от приёма сообщений
	Всё решилось куда проще: для ФреймЛистенера устанавливается флаг выключения, и при следущем
	кадре он вырубается. Пока сойдёт, хотя не самое красивое решение. Теперь надо 
	включить обновление для систем.
[10.05.08] Остались ещё лики в классфактори. Надо бы исправить. Но главное сейчас- сделать управление
	юнитом.
	Сначала я сделаю управление камерой с помощью мыши\клавы. Хм... получается даже красиво
	Мне это снова начинает нравиться
	Завожу обновление для всех объектов- Завёл. 
	Теперь бы уровень оживить.
[13.05.08] Будем скрипты оживлять. Луа. Нет, сначала сделать управление камерой.

1. static sceneryDef
2. registerTemplate->createDefinition->sceneryDef
3. static colliderDef
4. static unitDef
5. static bodyDef
6. registerTemplate->createDefinition->unitDef
7. registerType->createDefinition->sceneryDef
8. registerType->createDefinition->unitDef
9. registerType->createDefinition->sceneryDef
10. registerType->createDefinition->unitDef
-bodyDef
-unitDef
-colliderDef
-sceneryDef

[08.08.08] Вынес использование luabind в отдельную статическую библиотеку. Время сборки
	существенно ускорилось.
[29.08.08] Сначала нужно сделать разделение ClassFactory на Serialiser и ObjectFactory
	Наверное сначала я в скриптах попробую создать 2 бокса и мотор между ними.
	
	AttachBoneDef
	{
		string boneName;		
	}
	AttachAxisDef
	{
		vec3 center;
		vec3 up;
		vec3 front;
	}
[11.03.09] Создаём простенькую модель
	
[04.09.09] Проблема: объект не приходит в точку

что ещё сделаем:
	1. Попробую ещё разок завести отладочную графику от Nx
	2. Движение танка за курсором. - двигаем вручную юнита, другой гонится за ним
	3. Стрельба/Атака
	4. 
	
	
Imp=UnitDef('Imp')
{
	...
	model=ModelDef('imp') -- model - тоже твёрдая таблица
	{
		modelName=...
		materialName=...
		scale=...
	}
	...
}
импы бегают, теперь заняться нормальным описанием моделей
1. defObject возвращает всё-же твёрдую таблицу!


Мотиваторы (весь список):
- голод. Возникает когда запас энергии иссякает	
	если в инвентаре - сьедаем, иначе - идём в <hatchery>	
- сохранение жизни (страх). при высоком <danger level> окружающих объектов
	избегаем угрозы	
- задания хозяина.
	выполняем либо прямое указание либо от менежера
- тренеровка (работа в комнате). Постоянный уровень.
- охота. Постоянный уровень.
	

[22.09.09] Надо править цикл обновления.
	Так же проблема в поиске пути.
	Надо вывести координаты мыши куда-нить.
[29.09.09] Прицеплю ка я ручное управление, к нему же и камеру.
	Затем надо сделать отрисовку найденного маршрута.
[02.10.09] Улучшаем курсор мышиный. 
	Курсор улучшен. Теперь стоит довести до ума работу с картой. 
		map->addWallTemplate4({	0,3,0,
								1,3,3,
								1,1,0},"blocks/brickCorner.mesh");
[16.10.09] Гуд факинг морнинг. Обрадовать что-ли мир портированием старой
	рисовалки от ЁКЛМН...
	Ага, ещё остаётся вкопипастить в DKMap полномочия RenderManager. Распиливать потом буду
	Урра! Эта штука почти не работает. Ну всмысле совсем не работает.
[17.10.09] 
	Чего я хочу? Чего я хочу? Чего я хочу?
	Рисование карты. Херовато с рисованием карты. Код который я вроде почти не менял
	всё-таки сломался, а значит тайлить придётся заново. 
	Сначала надо убедиться, что	рисутеся что-то чертовски простое, например просто тайл. Как?
	как вариант - сделать уровень 3х3, и изучать центральный блок.
	Чтож, пока другие мысли шепчут тихо, сделаю я тестовый уровень.
[17.10.09] Тайлить заново не пришлось, пришлось перевернуть текстуру.
	Теперь поправить крышу, она немного уехала, ровненько на (x*cellSize,y*cellSize) в каждом направлении
	Релиз по прежнему некорректно работает. Это нехорошо, даже наверное очень нехорошо.
	Как крышу поправлю - засунуть бы в скрипт инициализацию тайлов. Это будет очень хорошо.
	Крыша на месте. А заодно отсечение работает, кстате релиз тоже. Теперь придать твёрдость карте, и импов селить.
	
	Нафик пока твёрдость уровня. Надо оформить класс MeshGenerator, который будет заниматься созданием и складированием
	сеток. Чтож, сначала надо то, что есть сейчас сделать более локальным. Создание блока (без потолка) зависит только
	от типов соседних блоков. Займусь именно этим.

[26.04.11] Притащил старый лог в TiGa. Эх много с тех пор изменилось. Надо срочно делать настройки для карты
	Что огорчает:
		1. Сильно разные скрипты про инициализацию уровня и прочий ввод-вывод для редактора уровней и для игрового режима
		2. Надо продумать обратную связь для Property Grid
		3. Зависание при вызове dumpdata, связанное с циклическими ссылками

	Раздумья про property.
		Сейчас всё конечные контроллы имеют следующую структуру
			owner - ссылка на владельца
			ownerKey - имя редактируемого поля
			parent - ссылка на родительский контролл
			control - ссылка на iup элемент управления
			getValue(self) - функция, которая возвращает реальное значение owner[ownerKey]
			updateUp(self) - функция, вызываемая если какое-то поле изменилось снизу, 
				т.е через элемент управления, или через дочерний элемент управления. 
				Распространение обновления вверх по иерархии
			updateDown(self) - функция, вызываемая если какое-то поле изменилось сверху, 
				т.е не через элементы управления. Требуется обновить содержимое элементов управления.
				Распространение обновления вниз по иерархии
		owner+ownerKey не являются обязательными для этой структуры, всё лезет через getValue
		Сразу после создания контролла требуется вызвать updateDown чтобы задать начальное значение полей

	Нужен подсчёте ссылок в FxEffect, причём было бы неплохо расшареные счётчики положить внутрь FxManager

	Предыдущие маршрутные точки не следует удалять - они нужны чтобы отслеживать отклонение от заданого маршрута

	От LuaObject следует избавиться. _Scripter::Object куда правильнее
[27.04.11] Следует чаще использовать for_each для пробега по контейнерам
	Требуется выводить FPS - готово.

	Расследовать, почему на месте не стоится роботам. Расследовал. Стоят нормально

	Поглядеть профилёр. Поглядел, много чего обнаружил, обнаруженое поправил. 
	Затык был в VelocityObstacle::rayCast, лишней нормализации, лишних vec2f(cosf(angle),sinf(angle))
	Часть кешировал, часть оказалось очень ненужной. Сделал упрощёные версии некоторых функций.
	Надо потом испытать более быструю версию rayCast, которая сильно раньше определяет пересечение с объектом
[28.04.11] Проверить почему квад не пашет
[29.04.11] Нажатия на кнопку отрабатываются по несколько раз. Mouse Up отрабатывается не всегда	